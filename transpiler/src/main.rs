use std::{
    fs,
    process::{self, Stdio},
};

fn run() -> Result<(), Error> {
    // make a workdir folder
    match run_command("mkdir", &["workdir"], "Create work dir", None, true) {
        Ok(_) => (),
        Err(_) => {
            run_command("rm", &["-rf", "workdir"], "Remove work dir", None, false)?;
            run_command("mkdir", &["workdir"], "Create work dir", None, false)?;
        }
    };

    // git clone chartjs
    run_command(
        "git",
        &["clone", "https://github.com/chartjs/Chart.js.git"],
        "Clone Chart.js repo",
        Some("workdir"),
        false,
    )?;

    // list tags
    let tag = run_command(
        "git",
        &["rev-list", "--tags", "--max-count=1"],
        "List Chart.js tags",
        Some("workdir/Chart.js"),
        false,
    )?;

    // get most recent tags
    let recent = run_command(
        "git",
        &["describe", "--tags", tag.trim()],
        "Get most recent tags",
        Some("workdir/Chart.js"),
        false,
    )?;

    // check out most recent tag
    run_command(
        "git",
        &["checkout", recent.trim()],
        "Checkout tag",
        Some("workdir/Chart.js"),
        false,
    )?;

    // fix tsconfig
    let ts = fs::read_to_string("workdir/Chart.js/tsconfig.json")
        .map_err(|e| Error::Err(e.to_string()))?;
    let ts = ts
        .replace("[\"offscreencanvas\"]", "[], // [\"offscreencanvas\"]")
        .replace("\"./src/**/*.js\"", "// \"./src/**/*.js\"");
    fs::write("workdir/Chart.js/tsconfig.json", ts).map_err(|e| Error::Err(e.to_string()))?;

    // install TypeConv
    run_command(
        "npm",
        &["install", "typeconv"],
        "Install TypeConv",
        Some("workdir"),
        false,
    )?;

    // install quicktype
    run_command(
        "npm",
        &["install", "quicktype"],
        "Install Quicktype",
        Some("workdir"),
        false,
    )?;

    // run TypeConv
    run_command(
        "npx",
        &[
            "typeconv",
            "-f",
            "ts",
            "-t",
            "jsc",
            "-o",
            "./output",
            "Chart.js/types/*",
        ],
        "Run Type Doc",
        Some("workdir"),
        false,
    )?;

    let version = env!("CARGO_PKG_VERSION");
    let now = run_command("date", &[], "Get UTC now", None, false)?;

    // run quicktype

    run_command(
        "npx",
        &[
            "quicktype",
            "--src",
            "output/index.esm.json",
            "--lang",
            "rust",
            "--out",
            "../api/src/types.rs",
        ],
        "Run QuickType on index.esm.json",
        Some("workdir"),
        false,
    )?;

    // fix rust files
    {
        let ty = fs::read_to_string("api/src/types.rs")
            .map_err(|e| Error::Err(e.to_string()))?
            .replace("\n\n    ", "\n    ");

        let mut ty = ty
            .lines()
            .skip(14)
            .map(ToOwned::to_owned)
            .collect::<Vec<String>>();
        ty.reverse();
        ty.push("use serde::{Deserialize, Serialize};".into());
        ty.push(format!(
            "/// Generated by chart-js-rs/transpiler v{version} on {now}"
        ));
        ty.reverse();
        let ty = ty.join("\n");

        fs::write("api/src/types.rs", ty).map_err(|e| Error::Err(e.to_string()))?;
    }

    run_command("cargo", &["fmt"], "cargo fmt", None, false)?;

    Ok(())
}

fn main() {
    let run = run();
    if run.is_ok() {
        println!("Succeeded all commands")
    };

    // remove workdir
    let _ = run_command("rm", &["-rf", "workdir"], "Remove work dir", None, false);

    if run.is_err() {
        eprintln!("{:#?}", run.err());
        process::exit(1);
    }
}

fn run_command(
    cmd: &str,
    args: &[&str],
    name: &str,
    cd: Option<&str>,
    ignore_err: bool,
) -> Result<String, Error> {
    let child = process::Command::new(cmd)
        .args(args)
        .current_dir(cd.unwrap_or("."))
        .stderr(Stdio::piped())
        .stdin(Stdio::piped())
        .output();

    if !ignore_err {
        let child = child.map_err(|e| Error::Err(e.to_string()))?;

        if !child.status.success() && !ignore_err {
            eprintln!(
                "{}",
                String::from_utf8(child.stderr).map_err(|e| Error::Err(e.to_string()))?
            );
            eprintln!("\r   Failed Command: ({name}) ✖");

            Err(Error::Err(String::new()))
        } else {
            println!("\rSucceeded Command: ({name}) ✔");

            String::from_utf8(child.stdout).map_err(|e| Error::Err(format!("{name} errored: {e}")))
        }
    } else {
        println!("\rSucceeded Command: ({name}) ✔");

        Ok(String::new())
    }
}

#[derive(Debug, Clone)]
enum Error {
    Err(String),
}
