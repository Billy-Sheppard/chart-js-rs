use std::{
    fs,
    process::{self, Stdio},
};

fn run() -> Result<(), Error> {
    // make a workdir folder
    match run_command("mkdir", &["workdir"], "Create work dir", None) {
        Ok(_) => (),
        Err(_) => {
            run_command("rm", &["-rf", "workdir"], "Remove work dir", None)?;
            run_command("mkdir", &["workdir"], "Create work dir", None)?;
        }
    };

    
    // git clone chartjs
    run_command(
        "git",
        &["clone", "https://github.com/chartjs/Chart.js.git"],
        "Clone Chart.js repo",
        Some("workdir"),
    )?;

    // list tags
    let tag = run_command(
        "git",
        &["rev-list", "--tags", "--max-count=1"],
        "List Chart.js tags",
        Some("workdir/Chart.js"),
    )?;
    
    // get most recent tags
    let recent = run_command(
        "git",
        &["describe", "--tags", tag.trim()],
        "Get most recent tags",
        Some("workdir/Chart.js"),
    )?;
    
    // check out most recent tag
    run_command(
        "git",
        &["checkout", recent.trim()],
        "Checkout tag",
        Some("workdir/Chart.js"),
    )?;
    
    // copy in typedoc
    run_command("cp", &["./typedoc.json", "./workdir/Chart.js/typedoc.json"], "Copy in typedoc config", None)?;

    // fix tsconfig
    let ts = fs::read_to_string("workdir/Chart.js/tsconfig.json")
        .map_err(|e| Error::Err(e.to_string()))?;
    let ts = ts
        .replace("[\"offscreencanvas\"]", "[] // [\"offscreencanvas\"]")
        .replace("\"./src/**/*.js\"", "// \"./src/**/*.js\"");
    fs::write("workdir/Chart.js/tsconfig.json", ts).map_err(|e| Error::Err(e.to_string()))?;

    // install typedoc
    run_command(
        "npm",
        &["install", "typedoc"],
        "Install TypeDoc",
        Some("workdir"),
    )?;

    // install quicktype
    run_command(
        "npm",
        &["install", "quicktype"],
        "Install Quicktype",
        Some("workdir"),
    )?;

    // run typedoc
    run_command(
        "../node_modules/.bin/typedoc",
        &["types/index.esm.d.ts", "--json", "../output.json"],
        "Run Type Doc",
        Some("workdir/Chart.js"),
    )?;

    // run quicktype
    run_command(
        "node_modules/.bin/quicktype",
        &[
            "--src",
            "output.json",
            "--lang",
            "rust",
            "--out",
            "../api/src/types.rs",
        ],
        "Run QuickType",
        Some("workdir"),
    )?;

    // fix types.rs
    {
        let version = env!("CARGO_PKG_VERSION");
        let now = run_command("date", &[], "Get UTC now", None)?;

        let ty = fs::read_to_string("api/src/types.rs")
            .map_err(|e| Error::Err(e.to_string()))?
            .replace("\n\n    ", "\n    ");

        let mut ty = ty
            .lines()
            .skip(14)
            .map(ToOwned::to_owned)
            .collect::<Vec<String>>();
        ty.reverse();
        ty.push("use serde::{Deserialize, Serialize};".into());
        ty.push(format!("/// Generated by transpiler v{version} on {now}"));
        ty.reverse();

        fs::write("api/src/types.rs", ty.join("\n")).map_err(|e| Error::Err(e.to_string()))?;
    }

    Ok(())
}

fn main() {
    let run = run();
    if run.is_ok() {
        println!("Succeeded all commands")
    };

    // remove workdir
    // let _ = run_command("rm", &["-rf", "workdir"], "Remove work dir", None);

    if run.is_err() {
        eprintln!("{:#?}", run.err());
        process::exit(1);
    }
}

fn run_command(cmd: &str, args: &[&str], name: &str, cd: Option<&str>) -> Result<String, Error> {
    let child = process::Command::new(cmd)
        .args(args)
        .current_dir(cd.unwrap_or("."))
        .stderr(Stdio::piped())
        .stdin(Stdio::piped())
        .output()
        .map_err(|e| Error::Err(e.to_string()))?;

    if !child.status.success() {
        eprintln!(
            "{}",
            String::from_utf8(child.stderr).map_err(|e| Error::Err(e.to_string()))?
        );
        eprintln!("\rFailed Command: ({name}) ✖");

        Err(Error::Err(String::new()))
    } else {
        println!("\rSucceeded Command: ({name}) ✔");

        String::from_utf8(child.stdout).map_err(|e| Error::Err(format!("{name} errored: {e}")))
    }
}

#[derive(Debug, Clone)]
enum Error {
    Err(String),
}
